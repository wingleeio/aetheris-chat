// GENERATED by @edgedb/generate v0.5.3

import type {Executor} from "edgedb";

export type CreateEmailVerificationArgs = {
  readonly "user_id": string;
  readonly "code": string;
  readonly "expires_at": Date;
};

export type CreateEmailVerificationReturns = {
  "code": string;
};

export function createEmailVerification(client: Executor, args: CreateEmailVerificationArgs): Promise<CreateEmailVerificationReturns> {
  return client.queryRequiredSingle(`\
select (insert EmailVerificationCode {
      user := <User><uuid>$user_id,
      code := <str>$code,
      expires_at := <datetime>$expires_at
}) {
  code,
}`, args);

}


export type DeleteSessionArgs = {
  readonly "session_id": string;
};

export type DeleteSessionReturns = {
  "id": string;
} | null;

export function deleteSession(client: Executor, args: DeleteSessionArgs): Promise<DeleteSessionReturns> {
  return client.querySingle(`\
delete Session filter .session_id = <str>$session_id;`, args);

}


export type DeleteUserSessionsArgs = {
  readonly "user_id": string;
};

export type DeleteUserSessionsReturns = Array<{
  "id": string;
}>;

export function deleteUserSessions(client: Executor, args: DeleteUserSessionsArgs): Promise<DeleteUserSessionsReturns> {
  return client.query(`\
delete Session filter .user = <User><uuid>$user_id;`, args);

}


export type GetOauthAccountArgs = {
  readonly "provider_user_id": string;
};

export type GetOauthAccountReturns = {
  "user_id": string;
} | null;

export function getOauthAccount(client: Executor, args: GetOauthAccountArgs): Promise<GetOauthAccountReturns> {
  return client.querySingle(`\
select OAuth2Account {
  user_id := .user.id,
}
filter .provider_user_id = <str>$provider_user_id;`, args);

}


export type GetSessionAndUserArgs = {
  readonly "session_id": string;
};

export type GetSessionAndUserReturns = {
  "id": string;
  "session_id": string;
  "expires_at": Date;
  "user": {
    "id": string;
    "email": string;
    "email_verified": boolean;
    "profile": {
      "avatar_url": string | null;
      "cover_url": string | null;
      "display_name": string;
      "tag": string;
    } | null;
  };
} | null;

export function getSessionAndUser(client: Executor, args: GetSessionAndUserArgs): Promise<GetSessionAndUserReturns> {
  return client.querySingle(`\
with
  session := (select Session filter .session_id = <str>$session_id),
  user := (select User filter .id = session.user.id),
select session {
  id,
  session_id,
  expires_at,
  user: {
    id,
    email,
    email_verified,
    profile: {
      avatar_url,
      cover_url,
      display_name,
      tag,
    }
  }
}`, args);

}


export type GetUserSessionsArgs = {
  readonly "user_id": string;
};

export type GetUserSessionsReturns = Array<{
  "id": string;
  "session_id": string;
  "expires_at": Date;
  "user": {
    "id": string;
  };
}>;

export function getUserSessions(client: Executor, args: GetUserSessionsArgs): Promise<GetUserSessionsReturns> {
  return client.query(`\
select Session {
  id,
  session_id,
  expires_at,
  user: {
    id
  }
} filter .user = <User><uuid>$user_id;`, args);

}


export type GetUserWithHashedPasswordArgs = {
  readonly "email": string;
};

export type GetUserWithHashedPasswordReturns = {
  "id": string;
  "hashed_password": string | null;
} | null;

export function getUserWithHashedPassword(client: Executor, args: GetUserWithHashedPasswordArgs): Promise<GetUserWithHashedPasswordReturns> {
  return client.querySingle(`\
select User {
  id,
  hashed_password
}
filter .email = <str>$email`, args);

}


export type SetSessionArgs = {
  readonly "session_id": string;
  readonly "expires_at": Date;
  readonly "user_id": string;
};

export type SetSessionReturns = {
  "id": string;
};

export function setSession(client: Executor, args: SetSessionArgs): Promise<SetSessionReturns> {
  return client.queryRequiredSingle(`\
insert Session {
  session_id := <str>$session_id,
  expires_at := <datetime>$expires_at,
  user := <User><uuid>$user_id,
}`, args);

}


export type UpdateSessionExpirationArgs = {
  readonly "expires_at": Date;
  readonly "session_id": string;
};

export type UpdateSessionExpirationReturns = {
  "id": string;
} | null;

export function updateSessionExpiration(client: Executor, args: UpdateSessionExpirationArgs): Promise<UpdateSessionExpirationReturns> {
  return client.querySingle(`\
update Session
filter .session_id = <str>$session_id
set {
  expires_at := <datetime>$expires_at
}`, args);

}


export type UpdateUserArgs = {
  readonly "email"?: string | null;
  readonly "hashed_password"?: string | null;
  readonly "email_verified"?: boolean | null;
  readonly "user_id": string;
};

export type UpdateUserReturns = {
  "id": string;
} | null;

export function updateUser(client: Executor, args: UpdateUserArgs): Promise<UpdateUserReturns> {
  return client.querySingle(`\
update User
filter .id = <uuid>$user_id
set {
    email := <optional str>$email ?? .email,
    hashed_password := <optional str>$hashed_password ?? .hashed_password,
    email_verified := <optional bool>$email_verified ?? .email_verified,
}`, args);

}


export type VerifyEmailArgs = {
  readonly "code": string;
};

export type VerifyEmailReturns = boolean | null;

export function verifyEmail(client: Executor, args: VerifyEmailArgs): Promise<VerifyEmailReturns> {
  return client.querySingle(`\
with
  email_verification_code := (select EmailVerificationCode filter .user = <User><uuid>global current_user_id),
  expired := email_verification_code.expires_at < datetime_current()
select email_verification_code.code = <str>$code and not expired;`, args);

}


export type AddEmojiArgs = {
  readonly "community_id": string;
  readonly "code": string;
  readonly "emoji_url": string;
};

export type AddEmojiReturns = {
  "id": string;
  "code": string;
  "emoji_url": string;
};

export function addEmoji(client: Executor, args: AddEmojiArgs): Promise<AddEmojiReturns> {
  return client.queryRequiredSingle(`\
select(insert Emoji {
    community := <Community><uuid>$community_id,
    code := <str>$code,
    emoji_url := <str>$emoji_url
}) {
    id,
    code,
    emoji_url,
}`, args);

}


export type CreateChannelArgs = {
  readonly "name": string;
  readonly "community_id": string;
};

export type CreateChannelReturns = {
  "id": string;
};

export function createChannel(client: Executor, args: CreateChannelArgs): Promise<CreateChannelReturns> {
  return client.queryRequiredSingle(`\
select (insert Channel {
  name := <str>$name,
  community := <Community><uuid>$community_id,
}) {
  id
}`, args);

}


export type CreateCommunityArgs = {
  readonly "name": string;
  readonly "about": string;
  readonly "icon_url"?: string | null;
  readonly "cover_url"?: string | null;
};

export type CreateCommunityReturns = {
  "id": string;
};

export function createCommunity(client: Executor, args: CreateCommunityArgs): Promise<CreateCommunityReturns> {
  return client.queryRequiredSingle(`\
select (insert Community {
    name := <str>$name,
    about := <str>$about,
    icon_url := <optional str>$icon_url,
    cover_url := <optional str>$cover_url,
    owner := <User>global current_user_id,
    members := (
        select User
        filter .id = global current_user_id
    )
}) {
    id
}`, args);

}


export type DeleteChannelMessagesArgs = {
  readonly "channel_id": string;
};

export type DeleteChannelMessagesReturns = Array<{
  "id": string;
}>;

export function deleteChannelMessages(client: Executor, args: DeleteChannelMessagesArgs): Promise<DeleteChannelMessagesReturns> {
  return client.query(`\
delete Message
filter .channel.id = <uuid>$channel_id`, args);

}


export type DeleteEmojiArgs = {
  readonly "emoji_id": string;
};

export type DeleteEmojiReturns = {
  "id": string;
} | null;

export function deleteEmoji(client: Executor, args: DeleteEmojiArgs): Promise<DeleteEmojiReturns> {
  return client.querySingle(`\
delete Emoji filter .id = <uuid>$emoji_id`, args);

}


export type DoesEmojiCodeAlreadyExistArgs = {
  readonly "code": string;
  readonly "community_id": string;
};

export type DoesEmojiCodeAlreadyExistReturns = boolean;

export function doesEmojiCodeAlreadyExist(client: Executor, args: DoesEmojiCodeAlreadyExistArgs): Promise<DoesEmojiCodeAlreadyExistReturns> {
  return client.queryRequiredSingle(`\
select exists(
  select Emoji filter .code = <str>$code and .community = <Community><uuid>$community_id
)`, args);

}


export type DeleteChannelArgs = {
  readonly "channel_id": string;
};

export type DeleteChannelReturns = {
  "id": string;
} | null;

export function deleteChannel(client: Executor, args: DeleteChannelArgs): Promise<DeleteChannelReturns> {
  return client.querySingle(`\
delete Channel
filter .id = <uuid>$channel_id`, args);

}


export type GetChannelArgs = {
  readonly "channel_id": string;
};

export type GetChannelReturns = {
  "id": string;
  "name": string;
} | null;

export function getChannel(client: Executor, args: GetChannelArgs): Promise<GetChannelReturns> {
  return client.querySingle(`\
select Channel {
  id,
  name
}
filter .id = <uuid>$channel_id`, args);

}


export type GetChannelsArgs = {
  readonly "community_id": string;
};

export type GetChannelsReturns = Array<{
  "id": string;
  "name": string;
  "owner_id": string;
  "unread_count": number;
}>;

export function getChannels(client: Executor, args: GetChannelsArgs): Promise<GetChannelsReturns> {
  return client.query(`\
select Channel {
  id,
  name,
  owner_id := .community.owner.id,
  unread_count := count(
    .messages 
    filter .created_at > 
    (select .channel.read_status filter .user = <User>global current_user_id).last_read_at
  ),
}
filter .community.id = <uuid>$community_id`, args);

}



export type GetCommunitiesReturns = Array<{
  "id": string;
  "name": string;
  "about": string;
  "icon_url": string | null;
  "cover_url": string | null;
  "is_member": boolean;
  "member_count": number;
  "messages_since_yesterday": number;
}>;

export function getCommunities(client: Executor): Promise<GetCommunitiesReturns> {
  return client.query(`\
select Community {
    id,
    name,
    about,
    icon_url,
    cover_url,
    is_member := count(.members filter .id = global current_user_id) > 0,
    member_count := count(.members),
    messages_since_yesterday := count(.channels.messages filter .created_at > datetime_current() - <cal::date_duration>'1 day')
}
order by .member_count desc`);

}


export type GetCommunityFromChannelArgs = {
  readonly "channel_id": string;
};

export type GetCommunityFromChannelReturns = {
  "id": string;
} | null;

export function getCommunityFromChannel(client: Executor, args: GetCommunityFromChannelArgs): Promise<GetCommunityFromChannelReturns> {
  return client.querySingle(`\
select Community {
    id,
}
filter .channels.id = <uuid>$channel_id
limit 1`, args);

}


export type GetCommunityArgs = {
  readonly "community_id": string;
};

export type GetCommunityReturns = {
  "id": string;
  "name": string;
  "about": string;
  "icon_url": string | null;
  "cover_url": string | null;
  "member_count": number;
  "owner_id": string;
  "emojis": Array<{
    "id": string;
    "code": string;
    "emoji_url": string;
  }>;
} | null;

export function getCommunity(client: Executor, args: GetCommunityArgs): Promise<GetCommunityReturns> {
  return client.querySingle(`\
select Community {
    id,
    name,
    about,
    icon_url,
    cover_url,
    member_count := count(.members),
    owner_id := .owner.id,
    emojis: {
        id,
        code,
        emoji_url,
    }
}
filter .id = <uuid>$community_id`, args);

}


export type GetEmojiArgs = {
  readonly "emoji_id": string;
};

export type GetEmojiReturns = {
  "community": {
    "id": string;
  };
} | null;

export function getEmoji(client: Executor, args: GetEmojiArgs): Promise<GetEmojiReturns> {
  return client.querySingle(`\
select Emoji {
  community: {
    id
  }
}
filter .id = <uuid>$emoji_id`, args);

}


export type GetEmojiByCommunityAndCodeArgs = {
  readonly "community_id": string;
  readonly "code": string;
};

export type GetEmojiByCommunityAndCodeReturns = {
  "emoji_url": string;
} | null;

export function getEmojiByCommunityAndCode(client: Executor, args: GetEmojiByCommunityAndCodeArgs): Promise<GetEmojiByCommunityAndCodeReturns> {
  return client.querySingle(`\
select Emoji {
  emoji_url,
}
filter .community = <Community><uuid>$community_id and .code = <str>$code
limit 1`, args);

}



export type GetMyCommunitiesReturns = Array<{
  "id": string;
  "name": string;
  "about": string;
  "icon_url": string | null;
  "cover_url": string | null;
  "member_count": number;
  "messages_since_yesterday": number;
  "has_unread": boolean;
}>;

export function getMyCommunities(client: Executor): Promise<GetMyCommunitiesReturns> {
  return client.query(`\
select Community {
    id,
    name,
    about,
    icon_url,
    cover_url,
    member_count := count(.members),
    messages_since_yesterday := count(.channels.messages filter .created_at > datetime_current() - <cal::date_duration>'1 day'),
    has_unread := count(
        .channels.messages 
        filter .created_at > 
        (select .channel.read_status filter .user = <User>global current_user_id).last_read_at
    ) > 0,
}
filter .members = <User>global current_user_id
order by .created_at desc`);

}


export type IsAllowedToDeleteChannelArgs = {
  readonly "channel_id": string;
};

export type IsAllowedToDeleteChannelReturns = boolean | null;

export function isAllowedToDeleteChannel(client: Executor, args: IsAllowedToDeleteChannelArgs): Promise<IsAllowedToDeleteChannelReturns> {
  return client.querySingle(`\
with 
  channel := (select Channel filter .id = <uuid>$channel_id),
  is_allowed := channel.community.owner.id = global current_user_id,
select is_allowed`, args);

}


export type IsAllowedToUpdateCommunityArgs = {
  readonly "community_id": string;
};

export type IsAllowedToUpdateCommunityReturns = boolean | null;

export function isAllowedToUpdateCommunity(client: Executor, args: IsAllowedToUpdateCommunityArgs): Promise<IsAllowedToUpdateCommunityReturns> {
  return client.querySingle(`\
with 
  community := (select Community filter .id = <uuid>$community_id),
  is_allowed := community.owner.id = global current_user_id,
select is_allowed`, args);

}


export type IsChannelMemberArgs = {
  readonly "channel_id": string;
};

export type IsChannelMemberReturns = boolean;

export function isChannelMember(client: Executor, args: IsChannelMemberArgs): Promise<IsChannelMemberReturns> {
  return client.queryRequiredSingle(`\
with 
  channel := (select Channel filter .id = <uuid>$channel_id),
  is_member := count(channel.community.members filter .id = global current_user_id) > 0,
select is_member`, args);

}


export type IsCommunityMemberArgs = {
  readonly "community_id": string;
};

export type IsCommunityMemberReturns = boolean;

export function isCommunityMember(client: Executor, args: IsCommunityMemberArgs): Promise<IsCommunityMemberReturns> {
  return client.queryRequiredSingle(`\
with 
  community := (select Community filter .id = <uuid>$community_id),
  is_member := count(community.members filter .id = global current_user_id) > 0,
select is_member`, args);

}


export type JoinCommunityArgs = {
  readonly "community_id": string;
};

export type JoinCommunityReturns = {
  "id": string;
} | null;

export function joinCommunity(client: Executor, args: JoinCommunityArgs): Promise<JoinCommunityReturns> {
  return client.querySingle(`\
update Community
filter .id = <uuid>$community_id
set {
    members += <User>global current_user_id
}`, args);

}


export type LeaveCommunityArgs = {
  readonly "community_id": string;
};

export type LeaveCommunityReturns = {
  "id": string;
} | null;

export function leaveCommunity(client: Executor, args: LeaveCommunityArgs): Promise<LeaveCommunityReturns> {
  return client.querySingle(`\
update Community
filter .id = <uuid>$community_id
set {
    members -= <User>global current_user_id
}`, args);

}


export type UpdateCommunityArgs = {
  readonly "name": string;
  readonly "about": string;
  readonly "icon_url"?: string | null;
  readonly "cover_url"?: string | null;
  readonly "community_id": string;
};

export type UpdateCommunityReturns = {
  "id": string;
} | null;

export function updateCommunity(client: Executor, args: UpdateCommunityArgs): Promise<UpdateCommunityReturns> {
  return client.querySingle(`\
select (
    update Community
    filter .id = <uuid>$community_id
    set {
        name := <str>$name,
        about := <str>$about,
        icon_url := <optional str>$icon_url ?? .icon_url,
        cover_url := <optional str>$cover_url ?? .cover_url,
    }
) {
    id
}`, args);

}


export type GetMessagesByChannelArgs = {
  readonly "cursor"?: string | null;
  readonly "take"?: number | null;
  readonly "channel_id": string;
};

export type GetMessagesByChannelReturns = {
  "messages": Array<{
    "id": string;
    "content": string;
    "created_at": Date;
    "updated_at": Date;
    "sender_id": string;
  }>;
  "has_more": boolean;
};

export function getMessagesByChannel(client: Executor, args: GetMessagesByChannelArgs): Promise<GetMessagesByChannelReturns> {
  return client.queryRequiredSingle(`\
with
    cursor := <optional uuid>$cursor ?? <uuid>"00000000-0000-0000-0000-000000000000",
    take  := <optional int64>$take ?? <int64>30,
    last_created_at := (select Message { created_at } filter .id = cursor).created_at ?? datetime_of_statement(),
    channel_id := <uuid>$channel_id,
    messages := (
        select Message
        filter .channel.id = channel_id and .created_at < last_created_at
        order by .created_at desc
        limit take
    ),
    remaining := count((select Message filter .channel.id = channel_id and .created_at < last_created_at)),
    has_more := remaining > count(messages)
select {
    messages := messages {
        id,
        content,
        created_at,
        updated_at,
        sender_id := .sender.id
    },
    has_more := has_more
}`, args);

}


export type MarkAsReadArgs = {
  readonly "channel_id": string;
};

export type MarkAsReadReturns = {
  "id": string;
};

export function markAsRead(client: Executor, args: MarkAsReadArgs): Promise<MarkAsReadReturns> {
  return client.queryRequiredSingle(`\
insert LastReadChannel {
    user := <User>global current_user_id,
    channel := <Channel><uuid>$channel_id,
}
unless conflict on (.user, .channel) 
else (
    update LastReadChannel
    set {
        last_read_at := datetime_current()
    }
)`, args);

}


export type SendChannelMessageArgs = {
  readonly "content": string;
  readonly "channel_id": string;
};

export type SendChannelMessageReturns = {
  "id": string;
  "content": string;
  "created_at": Date;
  "updated_at": Date;
  "sender_id": string;
};

export function sendChannelMessage(client: Executor, args: SendChannelMessageArgs): Promise<SendChannelMessageReturns> {
  return client.queryRequiredSingle(`\
select (insert Message {
    sender := <User>global current_user_id,
    content := <str>$content,
    channel := <Channel><uuid>$channel_id
}) {
    id,
    content,
    created_at,
    updated_at,
    sender_id := .sender.id,
}`, args);

}


export type CreateProfileArgs = {
  readonly "display_name": string;
  readonly "tag": string;
  readonly "bio"?: string | null;
  readonly "avatar_url"?: string | null;
  readonly "cover_url"?: string | null;
};

export type CreateProfileReturns = {
  "id": string;
};

export function createProfile(client: Executor, args: CreateProfileArgs): Promise<CreateProfileReturns> {
  return client.queryRequiredSingle(`\
insert Profile {
    display_name := <str>$display_name,
    tag := <str>$tag,
    bio := <optional str>$bio,
    avatar_url := <optional str>$avatar_url,
    cover_url := <optional str>$cover_url,
    user := <User>global current_user_id
}`, args);

}



export type GetAllEmojisReturns = Array<{
  "id": string;
  "name": string;
  "icon_url": string | null;
  "emojis": Array<{
    "id": string;
    "code": string;
    "emoji_url": string;
  }>;
}>;

export function getAllEmojis(client: Executor): Promise<GetAllEmojisReturns> {
  return client.query(`\
select Community {
  id,
  name,
  icon_url,
  emojis: {
    id,
    code,
    emoji_url,
  }
}
filter .members.id = global current_user_id`);

}


export type GetProfileArgs = {
  readonly "user_id": string;
};

export type GetProfileReturns = {
  "id": string;
  "display_name": string;
  "tag": string;
  "avatar_url": string | null;
  "cover_url": string | null;
  "bio": string | null;
} | null;

export function getProfile(client: Executor, args: GetProfileArgs): Promise<GetProfileReturns> {
  return client.querySingle(`\
select Profile {
    id,
    display_name,
    tag,
    avatar_url,
    cover_url,
    bio,
}
filter .user.id = <uuid>$user_id`, args);

}


export type UpdateProfileArgs = {
  readonly "display_name"?: string | null;
  readonly "tag"?: string | null;
  readonly "bio"?: string | null;
  readonly "avatar_url"?: string | null;
  readonly "cover_url"?: string | null;
};

export type UpdateProfileReturns = {
  "id": string;
} | null;

export function updateProfile(client: Executor, args: UpdateProfileArgs): Promise<UpdateProfileReturns> {
  return client.querySingle(`\
update Profile
filter .user.id = global current_user_id
set {
    display_name := <optional str>$display_name ?? .display_name,
    tag := <optional str>$tag ?? .tag,
    bio := <optional str>$bio ?? .bio,
    avatar_url := <optional str>$avatar_url ?? .avatar_url,
    cover_url := <optional str>$cover_url ?? .cover_url,
}`, args);

}


export type CreateOauthAccountArgs = {
  readonly "provider": string;
  readonly "provider_user_id": string;
  readonly "user_id": string;
};

export type CreateOauthAccountReturns = {
  "id": string;
};

export function createOauthAccount(client: Executor, args: CreateOauthAccountArgs): Promise<CreateOauthAccountReturns> {
  return client.queryRequiredSingle(`\
insert OAuth2Account {
  provider := <str>$provider,
  provider_user_id := <str>$provider_user_id,
  user := <User><uuid>$user_id,
}`, args);

}


export type DeleteEmailVerificationCodesArgs = {
  readonly "user_id": string;
};

export type DeleteEmailVerificationCodesReturns = {
  "id": string;
} | null;

export function deleteEmailVerificationCodes(client: Executor, args: DeleteEmailVerificationCodesArgs): Promise<DeleteEmailVerificationCodesReturns> {
  return client.querySingle(`\
delete EmailVerificationCode filter .user = <User><uuid>$user_id`, args);

}


export type CreateUserArgs = {
  readonly "email": string;
  readonly "hashed_password"?: string | null;
  readonly "email_verified": boolean;
};

export type CreateUserReturns = {
  "id": string;
};

export function createUser(client: Executor, args: CreateUserArgs): Promise<CreateUserReturns> {
  return client.queryRequiredSingle(`\
insert User {
  email := <str>$email,
  hashed_password := <optional str>$hashed_password,
  email_verified := <bool>$email_verified,
}`, args);

}



export type DeleteExpiredSessionsReturns = Array<{
  "id": string;
}>;

export function deleteExpiredSessions(client: Executor): Promise<DeleteExpiredSessionsReturns> {
  return client.query(`\
delete Session filter .expires_at < datetime_current();`);

}
